package Command v1.0.0;

use strict;
use warnings;

use constant TRUE  => 1;
use constant FALSE => 0;

use Data::Printer;

sub new {
    my $class = shift;
    my %args  = @_;
    my $self  = {
        verb      => $args{'verb'},
        templates => $args{'templates'},
        context   => $args{'context'},
        code      => $args{'code'},
        DEBUG     => $args{'DEBUG'} || 0,
        matching_template => undef,
    };
    $self->{vars} = {};  # Store variables from template

    bless( $self, $class );
    return $self;
}

sub matches {
    my( $self, $sent ) = @_;
    my $does_match = 0;
    foreach my $t ( @{$self->{templates}} ) {
        if( $self->template_match( $t, $sent ) ) {
            $does_match = 1;
            $self->{matching_template} = $t;
            last;
        }
    }
    return $does_match;
}

# Check for special chars indicating non-literal template token
sub _is_literal {
    my( $self, $tok ) = @_;
    return 1 if $tok !~ /[\|\[\$\.]/;
    return 0;
}

sub _is_or {
    my( $self, $tok ) = @_;
    return 1 if $tok =~ /\w+\|/;
    return 0;
}

sub _is_optional {
    my( $self, $tok ) = @_;
    return 1 if $tok =~ /^\[.+\]/;
    return 0;
}

sub _is_yadayada {
    my( $self, $tok ) = @_;
    if( $tok eq '...' ) {
        print "is_yadayada RETURNING 1\n";
        return 1; #  if $tok eq '...';
    }
    return 0;
}

sub _does_match {
    my( $self, $toke, $test ) = @_;
    if( $self->_is_literal( $test ) ) {
        if( $toke =~ /^$test$/ ) {
            # print " (literal) => 1\n";
            return 1;
        }
    }
    elsif( $self->_is_or( $test ) ) {
        my @choices = split /\|/, $test;
        my $m = 0;
        foreach( @choices ) {
            ++$m if $toke =~ /^$_$/;
        }
        if( $m > 0 ) {
            # print " (choice) => 1\n";
            return 1;
        }
    }
    # print " => 0\n";
    return 0;
}

sub template_match {
    my( $self, $template, $sentence ) = @_;
    my @sent = @{$sentence->tokens};
    my @temp = split /\s+/, $template;

    print "Command::template_match before loop:\n\tsent: @sent\n\ttemp: @temp\n\n";

    while( @temp or @sent ) {
        my $test = shift @temp;
        my $optional = 0;
        unless( $test ) {
            $test = "";
        }
        print "Command::template_match: at loop start:\n\ttemp = @temp\n\tsent = @sent\n\ttest = $test\n\tsent[0] = ", $sent[0], "\n\n";
        my $varname;
        if( $test =~ /^\$/ ) {
            print "\tCommand::template_match: test matches variable\n";
            ( $varname, $test ) = split ':', $test;
            $varname =~ s/^\$//;
            print "\tCommand::template_match: varname = $varname\n";
            unless( $test ) {
                print "\tCommand::template_match: no test, so setting vars\nCalling next\n\n";
                $self->{vars}->{$varname} = shift @sent;
                next;
            }
        }
        if( $self->_is_optional( $test ) ) {
            print "\tCommand::template_match: test optional = 1\n";
            $test =~ s/[\[\]]//g;  # strip '[' and ']' from exterior
            $optional = 1;
            print "\tCommand::template_match: test \$optional = 1\n";
        }
        if( $self->_is_yadayada( $test ) ) {
            print "\tCommand::template_match: test is_yadayada is True\n";
            $self->{vars}->{$varname} = join( ' ', @sent ) if $varname;
            @sent = ();
            next;
        }
        if( $self->_does_match( $sent[0], $test ) ) {
            print "\tCommand::template_match: ", $sent[0], " _does_match ", $test, "\n";
            my $val = shift @sent;
            print "\tCommand::template_match: shifting \'$val\' from sent\n\n";
            $self->{vars}->{$varname} = $val if $varname;
            next;
        }
        else {
            print "\tCommand::template_match: ", $sent[0], " ! _does_match ", $test, "\n";
            print "At end of loop:\n\tsent = @sent\n\ttemp = @temp\nCalling last!\n\n";
            last unless $optional;
        }
    }

    # If sentence tokens are left unmatched, return false.
    print "After a WHILE:\nsent = @sent\ntemp = @temp\n";
    if( @sent or @temp ) {
        print "Command::template_match RETURNING 0 ( FALSE )\n\n";
        return 0; # if( @sent or @temp );
    }
    print "Command::template_match RETURNING 1 (TRUE) \n\n";
    return 1;
}

1;

